//
//  FireExecutor.swift
//  DuckDuckGo
//
//  Copyright Â© 2025 DuckDuckGo. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import Core
import Common
import DDGSync
import Bookmarks
import AIChat
import BrowserServicesKit
import PrivacyConfig
import UserScript
import WKAbstractions

struct FireRequest {
    
    let options: Options
    let trigger: Trigger
    let scope: Scope
    struct Options: OptionSet {
        
        let rawValue: Int
        
        static let tabs = Options(rawValue: 1 << 0)
        static let data = Options(rawValue: 1 << 1)
        static let aiChats = Options(rawValue: 1 << 2)
        static let all: Options = [.tabs, .data, .aiChats]
        
        private static let descriptions: [(Options, String)] = [(.tabs, "tabs"), (.data, "data"),(.aiChats, "ai_chats")]
            
        var description: String {
            let components = Self.descriptions
                .filter { contains($0.0) }
                .map { $0.1 }
            return components.joined(separator: ",")
        }
    }
    
    enum Trigger {
        case manualFire              // User pressed Fire Button
        case autoClearOnLaunch       // Auto-clear during app launch
        case autoClearOnForeground   // Auto-clear after period of inactivity when returning to foreground
        
        var description: String {
            switch self {
            case .manualFire:
                return "manual_fire"
            case .autoClearOnLaunch:
                return "auto_clear_on_launch"
            case .autoClearOnForeground:
                return "auto_clear_on_foreground"
            }
        }
    }
    
    enum Scope {
        case tab(viewModel: TabViewModel)
        case all
        
        var description: String {
            switch self {
            case .tab:
                return "tab"
            case .all:
                return "all"
            }
        }
    }
}

protocol FireExecutorDelegate: AnyObject {
    func willStartBurning(fireRequest: FireRequest)
    func willStartBurningTabs(fireRequest: FireRequest)
    func didFinishBurningTabs(fireRequest: FireRequest)
    func willStartBurningData(fireRequest: FireRequest)
    func didFinishBurningData(fireRequest: FireRequest)
    func willStartBurningAIHistory(fireRequest: FireRequest)
    func didFinishBurningAIHistory(fireRequest: FireRequest)
    func didFinishBurning(fireRequest: FireRequest)
}

protocol FireExecuting {
    @MainActor func prepare(for request: FireRequest)
    @MainActor func burn(request: FireRequest,
                         applicationState: DataStoreWarmup.ApplicationState) async
    var delegate: FireExecutorDelegate? { get set }
    var dataClearingPixelsReporter: DataClearingPixelsReporter { get set }
}

class FireExecutor: FireExecuting {
    
    typealias HistoryCleanerProvider = () -> HistoryCleaning
    
    // MARK: - Variables
    
    private let tabManager: TabManaging
    private let downloadManager: DownloadManaging
    private let websiteDataManager: WebsiteDataManaging
    private let daxDialogsManager: DaxDialogsManaging
    private let syncService: DDGSyncing
    private weak var bookmarksDatabaseCleaner: BookmarkDatabaseCleaning?
    private let fireproofing: Fireproofing
    private let textZoomCoordinator: TextZoomCoordinating
    private let historyManager: HistoryManaging
    private let featureFlagger: FeatureFlagger
    private let privacyConfigurationManager: PrivacyConfigurationManaging
    private let dataStore: (any DDGWebsiteDataStore)?
    private let appSettings: AppSettings
    private let privacyStats: PrivacyStatsProviding?
    private let aiChatSyncCleaner: AIChatSyncCleaning

    weak var delegate: FireExecutorDelegate?
    private var burnInProgress = false
    private var dataStoreWarmup: DataStoreWarmup? = DataStoreWarmup()
    private let historyCleanerProvider: HistoryCleanerProvider
    private var preparedOptions: FireRequest.Options = []
    var dataClearingPixelsReporter: DataClearingPixelsReporter
    
    // MARK: - Init
    
    init(tabManager: TabManaging,
         downloadManager: DownloadManaging = AppDependencyProvider.shared.downloadManager,
         websiteDataManager: WebsiteDataManaging,
         daxDialogsManager: DaxDialogsManaging,
         syncService: DDGSyncing,
         bookmarksDatabaseCleaner: BookmarkDatabaseCleaning,
         fireproofing: Fireproofing,
         textZoomCoordinator: TextZoomCoordinating,
         historyManager: HistoryManaging,
         featureFlagger: FeatureFlagger,
         privacyConfigurationManager: PrivacyConfigurationManaging,
         dataStore: (any DDGWebsiteDataStore)? = nil,
         historyCleanerProvider: HistoryCleanerProvider? = nil,
         appSettings: AppSettings,
         privacyStats: PrivacyStatsProviding? = nil,
         aiChatSyncCleaner: AIChatSyncCleaning,
         dataClearingPixelsReporter: DataClearingPixelsReporter = .init()
    ) {
        self.tabManager = tabManager
        self.downloadManager = downloadManager
        self.websiteDataManager = websiteDataManager
        self.daxDialogsManager = daxDialogsManager
        self.syncService = syncService
        self.bookmarksDatabaseCleaner = bookmarksDatabaseCleaner
        self.fireproofing = fireproofing
        self.textZoomCoordinator = textZoomCoordinator
        self.historyManager = historyManager
        self.featureFlagger = featureFlagger
        self.privacyConfigurationManager = privacyConfigurationManager
        self.dataStore = dataStore
        self.historyCleanerProvider = historyCleanerProvider ??
        { return HistoryCleaner(featureFlagger: featureFlagger,
                                privacyConfig: privacyConfigurationManager)}
        self.appSettings = appSettings
        self.privacyStats = privacyStats
        self.aiChatSyncCleaner = aiChatSyncCleaner
        self.dataClearingPixelsReporter = dataClearingPixelsReporter
    }

    
    // MARK: - Public Functions
    @MainActor
    func prepare(for request: FireRequest) {
        // Only prepare tabs if requested and not already prepared
        if request.options.contains(.tabs) && !preparedOptions.contains(.tabs) {
            prepareForBurningTabs(scope: request.scope)
        }
        preparedOptions.formUnion(request.options)
    }
    
    @MainActor
    func burn(request: FireRequest,
              applicationState: DataStoreWarmup.ApplicationState) async {
        assert(delegate != nil, "Delegate should not be nil. This leads to unexpected behavior.")
        dataClearingPixelsReporter.fireRetriggerPixelIfNeeded()
        let startTime = CACurrentMediaTime()
        
        // Ensure all requested options are prepared
        let unpreparedOptions = request.options.subtracting(preparedOptions)
        if !unpreparedOptions.isEmpty {
            let newRequest = FireRequest(options: unpreparedOptions, trigger: request.trigger, scope: request.scope)
            prepare(for: newRequest)
        }
        
        // Notify delegate that we're starting
        delegate?.willStartBurning(fireRequest: request)
        
        // Compute flags
        let shouldBurnTabs = request.options.contains(.tabs)
        let shouldBurnData = request.options.contains(.data)
        let shouldBurnAIChats = shouldBurnAIHistory(request)
        
        // Pre-fetch domains once for tab scope when tabs or data burning is needed
        let domains: [String]?
        if case .tab(let viewModel) = request.scope, shouldBurnTabs || shouldBurnData {
            domains = await Array(viewModel.visitedDomains())
        } else {
            domains = nil
        }
        
        // Start async tasks
        async let dataTask: Void = shouldBurnData ? burnDataWithDelegateCallbacks(request: request, applicationState: applicationState, domains: domains) : ()
        
        async let aiTask: Void = shouldBurnAIChats ? burnAIHistoryWithDelegateCallbacks(request: request) : ()

        // Execute sync tasks
        cancelOngoingDownloadsIfNeeded(request)
        if shouldBurnTabs {
            burnTabsWithDelegateCallbacks(request: request, domains: domains)
        }
        
        // Await async tasks
        _ = await (dataTask, aiTask)
        
        // Notify delegate that we finished
        await didFinishBurning(fireRequest: request, startTime: startTime)
        
        // Reset prepared state for next burn cycle
        preparedOptions = []
    }
    
    // MARK: - General Helpers
    
    private func cancelOngoingDownloadsIfNeeded(_ request: FireRequest) {
        guard case .all = request.scope,
              request.options.contains(.tabs),
              request.options.contains(.data) else {
            return
        }
        downloadManager.cancelAllDownloads()
    }

    @MainActor
    private func didFinishBurning(fireRequest: FireRequest, startTime: CFTimeInterval) async {
        if case .tab(let viewModel) = fireRequest.scope,
           fireRequest.options.contains(.tabs) {
            await historyManager.removeTabHistory(for: [viewModel.tab.uid])
        }
        dataClearingPixelsReporter.fireClearingCompletionPixel(from: startTime, request: fireRequest)
        delegate?.didFinishBurning(fireRequest: fireRequest)
    }
    
    @MainActor
    private func burnTabsWithDelegateCallbacks(request: FireRequest, domains: [String]?) {
        delegate?.willStartBurningTabs(fireRequest: request)
        burnTabs(scope: request.scope, domains: domains)
        delegate?.didFinishBurningTabs(fireRequest: request)
    }
    
    @MainActor
    private func burnDataWithDelegateCallbacks(request: FireRequest,
                                               applicationState: DataStoreWarmup.ApplicationState,
                                               domains: [String]?) async {
        delegate?.willStartBurningData(fireRequest: request)
        await burnData(scope: request.scope, applicationState: applicationState, domains: domains)
        delegate?.didFinishBurningData(fireRequest: request)
    }
    
    @MainActor
    private func burnAIHistoryWithDelegateCallbacks(request: FireRequest) async {
        delegate?.willStartBurningAIHistory(fireRequest: request)
        await burnAIHistory(request: request)
        delegate?.didFinishBurningAIHistory(fireRequest: request)
    }
    
    // MARK: Burn Tabs Helpers

    @MainActor
    private func prepareForBurningTabs(scope: FireRequest.Scope) {
        switch scope {
        case .all:
            tabManager.prepareAllTabsExceptCurrentForDataClearing()
        case .tab(let viewModel):
            // Only prepare the tab if it's not the current tab
            // Current tabs are prepared during burnTabs
            if !tabManager.isCurrentTab(viewModel.tab) {
                tabManager.prepareTab(viewModel.tab)
            }
        }
    }
    
    @MainActor
    private func burnTabs(scope: FireRequest.Scope, domains: [String]?) {
        switch scope {
        case .all:
            let startTime = CACurrentMediaTime()
            tabManager.prepareCurrentTabForDataClearing()
            tabManager.removeAll()
            dataClearingPixelsReporter.fireDurationPixel(DataClearingPixels.burnTabsDuration, from: startTime, scope: scope)
            dataClearingPixelsReporter.fireResiduePixelIfNeeded(DataClearingPixels.burnTabsHasResidue) {
                tabManager.count > 0
            }
            Favicons.shared.clearCache(.tabs)
        case .tab(let viewModel):
            guard let domains else {
                Logger.general.error("Expected domains to be present when burning a single tab")
                return
            }
            let startTime = CACurrentMediaTime()
            // Prepare the tab if it's the current tab (non-current tabs were prepared earlier)
            if tabManager.isCurrentTab(viewModel.tab) {
                tabManager.prepareTab(viewModel.tab)
            }

            // Pass false to clearTabHistory to preserve tab history while burning
            // As tab history is needed by other processes running in parallel
            // didFinishBurning(fireRequest:) manually clears data after burn is complete
            // Close the tab and append a new empty tab, reusing existing one if exists
            tabManager.closeTabAndNavigateToHomepage(viewModel.tab, clearTabHistory: false)
            dataClearingPixelsReporter.fireDurationPixel(DataClearingPixels.burnTabsDuration, from: startTime, scope: scope)
            dataClearingPixelsReporter.fireResiduePixelIfNeeded(DataClearingPixels.burnTabsHasResidue) {
                tabManager.controller(for: viewModel.tab) != nil
            }

            Favicons.shared.removeTabFavicons(forDomains: domains)
        }
    }
    
    // MARK: - Clear Data Helpers
    
    @MainActor
    private func burnData(scope: FireRequest.Scope,
                          applicationState: DataStoreWarmup.ApplicationState,
                          domains: [String]?) async {
        guard !burnInProgress else {
            assertionFailure("Shouldn't get called multiple times")
            return
        }
        burnInProgress = true

        // This needs to happen only once per app launch
        if let dataStoreWarmup {
            await dataStoreWarmup.ensureReady(applicationState: applicationState)
            self.dataStoreWarmup = nil
        }

        switch scope {
        case .tab(let viewModel):
            await burnTabData(tabViewModel: viewModel, domains: domains)
        case .all:
            await burnAllData()
        }

        self.burnInProgress = false
    }
    
    @MainActor
    private func burnAllData() async {
        let urlSessionClearStartTime = CACurrentMediaTime()
        URLSession.shared.configuration.urlCache?.removeAllCachedResponses()
        dataClearingPixelsReporter.fireDurationPixel(DataClearingPixels.burnURLCacheDuration, from: urlSessionClearStartTime)
        dataClearingPixelsReporter.fireResiduePixelIfNeeded(DataClearingPixels.burnURLCacheHasResidue) {
            let cache = URLSession.shared.configuration.urlCache
            return (cache?.currentDiskUsage ?? 0) > 0 || (cache?.currentMemoryUsage ?? 0) > 0
        }

        let pixel = TimedPixel(.forgetAllDataCleared)
        
        // If the user is on a version that uses containers, then we'll clear the current container, then migrate it. Otherwise
        //  this is the same as `WKWebsiteDataStore.default()`
        let storeToUse = dataStore ?? DDGWebsiteDataStoreProvider.current()
        await websiteDataManager.clear(dataStore: storeToUse)
        pixel.fire(withAdditionalParameters: [PixelParameters.tabCount: "\(self.tabManager.count)"])

        AutoconsentManagement.shared.clearCache()
        daxDialogsManager.clearHeldURLData()

        if self.syncService.authState == .inactive {
            self.bookmarksDatabaseCleaner?.cleanUpDatabaseNow()
        }

        self.forgetTextZoom()
        let clearHistoryStartTime = CACurrentMediaTime()
        await historyManager.removeAllHistory()
        dataClearingPixelsReporter.fireDurationPixel(DataClearingPixels.burnURLCacheDuration, from: urlSessionClearStartTime)
        await privacyStats?.clearPrivacyStats()
    }
    
    @MainActor
    private func burnTabData(tabViewModel: TabViewModel, domains: [String]?) async {
        guard let domains else {
            Logger.general.error("Expected domains to be present when burning tab scoped data")
            return
        }
        // If the user is on a version that uses containers, then we'll clear the current container, then migrate it. Otherwise
        //  this is the same as `WKWebsiteDataStore.default()`
        let storeToUse = dataStore ?? DDGWebsiteDataStoreProvider.current()
        
        // Async tasks
        async let websiteDataTask: Void = websiteDataManager.clear(dataStore: storeToUse, forDomains: domains)
        async let historyTask: Void = historyManager.removeBrowsingHistory(tabID: tabViewModel.tab.uid)
        async let contextualChatTask: Void = deleteContextualChatIfNeeded(tabViewModel: tabViewModel)
        
        // Sync tasks
        AutoconsentManagement.shared.clearCache(forDomains: domains)
        forgetTextZoom(forDomains: domains)
        
        // Await async tasks
        _ = await (websiteDataTask, historyTask, contextualChatTask)
    }
    
    private func forgetTextZoom() {
        let allowedDomains = fireproofing.allowedDomains
        textZoomCoordinator.resetTextZoomLevels(excludingDomains: allowedDomains)
    }
    
    private func forgetTextZoom(forDomains domains: [String]) {
        let allowedDomains = fireproofing.allowedDomains
        textZoomCoordinator.resetTextZoomLevels(forVisitedDomains: domains, excludingDomains: allowedDomains)
    }
    
    @MainActor
    private func deleteContextualChatIfNeeded(tabViewModel: TabViewModel) async {
        guard appSettings.autoClearAIChatHistory,
              let contextualChatID = tabViewModel.currentContextualChatId else {
            return
        }
        let result = await deleteChat(chatID: contextualChatID)
        switch result {
        case .success:
            tabManager.controller(for: tabViewModel.tab)?.aiChatContextualSheetCoordinator.clearActiveChat()
        case .failure:
            Logger.aiChat.debug("Failed to delete contextual ai chat")
        }
    }
    
    // MARK: - Clear AI History
    
    /// For auto-clear with enhancedDataClearingSettings FF ON:
    /// - User configures what to clear via the enhanced settings UI
    /// For manual fire OR auto-clear with FF OFF (legacy):
    /// - AI chats clear only if autoClearAIChatHistory setting is enabled
    /// For single chat burning:
    /// - The user setting autoClearAIChatHistory should be ignored
    /// - Returns: A boolean indicating if we should run the ai chats burn flow
    private func shouldBurnAIHistory(_ request: FireRequest) -> Bool {
        let chosenThroughNewAutoClearUI = featureFlagger.isFeatureOn(.enhancedDataClearingSettings) && request.trigger != .manualFire

        var singleChatBurn: Bool = false
        if case .tab = request.scope { singleChatBurn = true }

        let shouldAllowAIChatsBurn = chosenThroughNewAutoClearUI
        || appSettings.autoClearAIChatHistory
        || singleChatBurn

        return request.options.contains(.aiChats) && shouldAllowAIChatsBurn
    }
    
    private func burnAIHistory(request: FireRequest) async {
        let startTime = CACurrentMediaTime()
        switch request.scope {
        case .tab(let viewModel):
            let startTime = Date()
            await burnTabAIHistory(tabViewModel: viewModel)
        case .all:
            let startTime = Date()
            await burnAllAIHistory(trigger: request.trigger)
        }
        dataClearingPixelsReporter.fireDurationPixel(DataClearingPixels.burnAIChatHistoryDuration, from: startTime, scope: request.scope)
    }
    
    private func burnAllAIHistory(trigger: FireRequest.Trigger) async {
        let cleaner = historyCleanerProvider()
        let result = await cleaner.cleanAIChatHistory()
        switch result {
        case .success:
            await recordAIChatsClearDate(trigger: trigger)
            DailyPixel.fireDailyAndCount(pixel: .aiChatHistoryDeleteSuccessful)
        case .failure(let error):
            Logger.aiChat.debug("Failed to clear Duck.ai chat history: \(error.localizedDescription)")
            DailyPixel.fireDailyAndCount(pixel: .aiChatHistoryDeleteFailed)
            dataClearingPixelsReporter.fireErrorPixel(DataClearingPixels.burnAIChatHistoryError(error))

            if let userScriptError = error as? UserScriptError {
                userScriptError.fireLoadJSFailedPixelIfNeeded()
            }
        }
    }
    
    private func burnTabAIHistory(tabViewModel: TabViewModel) async {
        if let chatID = await tabViewModel.currentAIChatId {
            await deleteChat(chatID: chatID)
        } else {
            Logger.aiChat.debug("No chatID found for tab, skipping single chat deletion")
        }
    }

    private func recordAIChatsClearDate(trigger: FireRequest.Trigger) async {
        switch trigger {
        case .manualFire:
            await aiChatSyncCleaner.recordLocalClear(date: Date())
        case .autoClearOnLaunch, .autoClearOnForeground:
            await aiChatSyncCleaner.recordLocalClearFromAutoClearBackgroundTimestampIfPresent()
        }
    }

    @discardableResult
    private func deleteChat(chatID: String) async -> Result<Void, Error> {
        let cleaner = historyCleanerProvider()
        let result = await cleaner.deleteAIChat(chatID: chatID)
        switch result {
        case .success:
            // TODO: - Add Pixel
            await aiChatSyncCleaner.recordChatDeletion(chatID: chatID)
        case .failure(let error):
            // TODO: - Add Pixel
            Logger.aiChat.debug("Failed to delete AI Chat: \(error.localizedDescription)")
            if let userScriptError = error as? UserScriptError {
                userScriptError.fireLoadJSFailedPixelIfNeeded()
            }
        }
        return result
    }
}
